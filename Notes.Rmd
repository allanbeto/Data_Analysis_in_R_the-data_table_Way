---
title: "Notes_datatable"
author: "Alan"
date: "2 de octubre de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Course Description
The R data.table package is rapidly making its name as the number one choice for handling large datasets in R. This online data.table tutorial will bring you from data.table novice to expert in no time. Once you are introduced to the general form of a data.table query, you will learn the techniques to subset your data.table, how to update by reference and how you can use data.tableâ€™s set()-family in your workflow. The course finishes with more complex concepts such as indexing, keys and fast ordered joins. Upon completion of the course, you will be able to use data.table in R for a more efficient manipulation and analysis process. Enjoy!


```{r}
#install.packages("data.table")
library("data.table")

```





## Data.table novice
    Introduction on what exactly a data.table is, how it differs from the traditional data.frame in R, and     understanding the general form of a data.table    query.


### Create and subset a data.table

Welcome to the interactive exercises for your data.table course. Here you will learn the ins and outs of working with the data.table package.

While most of the material is covered by Matt and Arun in the videos, you will sometimes need to show some street smarts to get to the right answer. Remember that before using the hint you can always have a look at the official documentation by typing ?data.table in the console.

Let's start with some warm-up exercises based on the topics covered in the video. Recall from the video that you can use L after a numeric to specify that it is an integer. You can also give columns with different lengths when creating a data.table, and R will "recycle" the shorter column to match the length of the longer one by re-using the first items. In the example below, column x is recycled to match the length of column y:

data.table(x = c("A", "B"), y = 1:4)
   x y
1: A 1
2: B 2
3: A 3
4: B 4
You can also review the slides used in the videos by pressing the slides button.

Instructions
Create a data.table my_first_data_table with a column x = c("a", "b", "c", "d", "e") and a column y = c(1, 2, 3, 4, 5). Use the function data.table().
Create a two-column data.table DT that contains the four integers 1, 2, 1 and 2 in the first column a and the letters A, B, C and D in the second column b. Use recycling so that the contents of a will be automatically used twice. Note that LETTERS[1] returns "A", LETTERS[2] returns "B", and so on.
Select the third row of DT and just print the result to the console.
Select the second and third rows without using commas and print the result to the console.

```{r}
# The data.table package is preloaded
library("data.table")
# Create my_first_data_table
my_first_data_table <- data.table(x = c("a", "b", "c", "d", "e"), 
                                  y = c(1, 2, 3, 4, 5)
                                  )
  
# Create a data.table using recycling
DT <- data.table(a = c(1L, 2L), b = LETTERS[1:4])
DT
# Print the third row to the console
DT[3]

# Print the second and third row to the console without using commas
DT[2:3]

```

## Getting to know a data.table

You can pass a data.table to base R functions like head() and tail() that accept a data.frame because data.tables are also data.frames. Also, keep in mind that the special symbol .N, when used inside square brackets, contains the number of rows. For example, DT[.N] and DT[nrow(DT)] will both return the last row in DT.

Instructions
Select the second to last row of the table using .N.
Return the column names() of the data.table.
Return the number of rows and number of columns of the data.table using the dim() function.
Select row 2 twice and row 3 once, returning a data.table with three rows (two of which are identical).


```{r}
# DT and the data.table package are pre-loaded

# Print the second to last row of DT using .N
DT[.N-1]

# Print the column names of DT
names(DT)

# Print the number or rows and columns of DT
dim(DT)

# Print a new data.table containing rows 2, 2, and 3 of DT
DT[c(2,2,3)]

```



## A data.table of a vector?

A data.table DT is preloaded in your workspace on the right. Type DT in the console to have a look at it. As you have learned in the video, you can select a column from that data.table with DT[, .(B)].

What do you think is the output of DT[, B]?

## A non-existing column

Have a close look at 1.1 and 1.2 from the data.table package FAQs.

Type D <- 5 in the console. What do you think is the output of DT[, .(D)] and DT[, D]?

Well done! Column D does not exist in DT and is thus not seen as a variable. This causes data.table to look for D in DT's parent frame. Also note that .() in j always returns a data.table


## Subsetting data.tables

As a reminder, DT[i, j, by] is pronounced

Take DT, subset rows using i, then calculate j grouped by by.

In the video, the second argument j was covered. j can be used to select columns by wrapping the column names in .().

In addition to selecting columns, you can also call functions on them as if the columns were variables. For example, if you had a data.table heights storing people's heights in inches, you could compute their heights in feet as follows:

    name  eye_color   height_inch
1:   Tom      Brown            69
2: Boris       Blue            71
3:   Jim       Blue            68

heights[, .(name, 
              height_ft = height_inch / 12)]
    name   height_ft
1:   Tom    5.750000
2: Boris    5.916667
3:   Jim    5.666667
Instructions
Create a subset containing the columns B and C for rows 1 and 3 of DT. Simply print out this subset to the console.
From DT, create a data.table, ans with two columns: B and val, where val is the product of A and C.
Fill in the blanks in the assignment of ans2, such that it equals the data.table specified in target. Use columns from the previously defined data.tables to produce the val column.

```{r}
# DT and the data.table package are pre-loaded

DT <- data.table(A = 1:5, B = c("a", "b", "c", "d", "e"), C = 6:10)

# Subset rows 1 and 3, and columns B and C
DT[c(1,3),.(B,C)]

# Assign to ans the correct value
ans <- DT[, .(B, val = A*C)]
ans  
# Fill in the blanks such that ans2 equals target
target <- data.table(B = c("a", "b", "c", "d", "e", 
                           "a", "b", "c", "d", "e"), 
                     val = as.integer(c(6:10, 1:5)))
ans2 <- DT[, .(B, val = c(6:10, 1:5))]
ans2

```


## Data.table yeoman
    Learn how to do multiple operations on the same data.table in one single statement, how to easily take     a subset of your data, update by reference, and work with the data.table set()-family.


### Chaining, the basics

Now that you are comfortable with data.table's DT[i, j, by] syntax, it is time to practice some other very useful concepts in data.table. Here, we'll have a more detailed look at chaining.

Chaining allows the concatenation of multiple operations in a single expression. It's easy to read because the operations are carried out from left to right. Furthermore, it helps to avoid the creation of unnecessary temporary variables (which could quickly clutter one's workspace).

Instructions
In the previous section, you calculated DT2 by taking the cumulative sum of C while grouping by A and B. Next, you selected the last two values of C from DT2 while grouping by A alone. This code is included in the sample code. Use chaining to restructure the code. Simply print out the result of chaining.    
    
```{r}
# The data.table package has already been loaded

# Build DT
DT <- data.table(A = rep(letters[2:1], each = 4L), 
                 B = rep(1:4, each = 2L), 
                 C = sample(8)) 
DT

# Combine the two steps in a one-liner
DT2 <- DT[, .(C = cumsum(C)), by = .(A, B)]
DT2
DT2[, .(C = tail(C, 2)), by = A]
```
    
    
    

## Data.table expert
    Discover the potential behind indexing, followed by generating and using keys. The final part focuses     on fast ordered joins.
